#! /usr/bin/env python
# encoding: utf-8

import os
import sys
import subprocess
from distutils.core import setup, Command
from distutils.extension import Extension
from distutils.version import StrictVersion


script_path = os.path.dirname(os.path.abspath(__file__))

# python-efl version
VERSION = "1.9"
RELEASE = "1.9.0"

# dependencies
CYTHON_MIN_VERSION = "0.17.0"
EFL_MIN_VERSION = "1.9.0"
ELM_MIN_VERSION = "1.9.0"


# XXX: Force default visibility. See phab T504
if os.getenv("CFLAGS") is not None and "-fvisibility=" in os.environ["CFLAGS"]:
    os.environ["CFLAGS"] += " -fvisibility=default"


# === Sphinx ===
try:
    from sphinx.setup_command import BuildDoc
except ImportError:
    class BuildDoc(Command):
        description = "build documentation using sphinx, that must be installed."
        user_options = []
        def initialize_options(self): pass
        def finalize_options(self): pass
        def run(self): print("Error: sphinx not found")


# === pkg-config ===
def pkg_config(name, require, min_vers=None):
    try:
        sys.stdout.write("Checking for " + name + ": ")

        call = subprocess.Popen(
            ["pkg-config", "--modversion", require], stdout=subprocess.PIPE)
        out, err = call.communicate()
        ver = out.decode("utf-8").strip()

        if min_vers is not None:
            assert 0 == subprocess.call(
                ["pkg-config", "--atleast-version", min_vers, require])

        call = subprocess.Popen(
            ["pkg-config", "--cflags", require], stdout=subprocess.PIPE)
        out, err = call.communicate()
        cflags = out.decode("utf-8").split()

        call = subprocess.Popen(
            ["pkg-config", "--libs", require], stdout=subprocess.PIPE)
        out, err = call.communicate()
        libs = out.decode("utf-8").split()

        sys.stdout.write("OK, found " + ver + "\n")

        return (cflags, libs)
    except (OSError, subprocess.CalledProcessError):
        print("Did not find " + name + " with 'pkg-config'.")
        return None
    except (AssertionError):
        print(name+" version mismatch. Found: "+ver+"  Needed: "+min_vers)
        return None


# use cython or pre-generated c files
if os.path.exists(os.path.join(script_path, "efl", "eo", "efl.eo.pyx")):
    module_suffix = ".pyx"
    try:
        from Cython.Distutils import build_ext
        from Cython.Build import cythonize
        import Cython.Compiler.Options

        assert StrictVersion(Cython.__version__) >= StrictVersion(CYTHON_MIN_VERSION)
        Cython.Compiler.Options.fast_fail = True # Stop compilation on first error
        Cython.Compiler.Options.annotate = False # Generates HTML files with annotated source
        Cython.Compiler.Options.docstrings = True # Set to False to disable docstrings

    except (ImportError, AssertionError):
        print("Requires Cython >= %s (http://cython.org/)" % CYTHON_MIN_VERSION)
        raise
else:
    module_suffix = ".c"
    from distutils.command.build_ext import build_ext
    def cythonize(modules, *args, **kwargs):
        return modules


class CleanGenerated(Command):
    description = "Clean C and html files generated by Cython"
    user_options = []
    def initialize_options(self): pass
    def finalize_options(self): pass
    def run(self):
        for lib in "eo", "evas", "ecore", "edje", "edje/edit", "emotion", "elementary", "utils":
            for root, dirs, files in os.walk(os.path.join(script_path, "efl", lib)):
                for f in files:
                    if f.endswith(".c") or f.endswith(".html"):
                        path = os.path.join(root, f)
                        os.remove(path)
        dbus_ml_path = os.path.join(script_path, "efl", "dbus_mainloop", "dbus_mainloop.c")
        if os.path.exists(dbus_ml_path):
            os.remove(dbus_ml_path)


modules = []
packages = ["efl"]
package_dirs = {}

if set(("build", "build_ext", "install", "bdist", "sdist")) & set(sys.argv):

    # === Eina ===
    eina_pkg_config = pkg_config('Eina', 'eina', EFL_MIN_VERSION)

    if eina_pkg_config is None:
        raise SystemExit("Eina required but not found!")
    else:
        eina_cflags, eina_libs = eina_pkg_config


    # === Eo ===
    eo_pkg_config = pkg_config('Eo', 'eo', EFL_MIN_VERSION)

    if eo_pkg_config is None:
        raise SystemExit("Eo required but not found!")
    else:
        eo_cflags, eo_libs = eo_pkg_config

        eo_ext = Extension("eo", ["efl/eo/efl.eo"+module_suffix],
                                define_macros = [('EFL_BETA_API_SUPPORT', None)],
                                include_dirs = ['include/'],
                                extra_compile_args = eo_cflags,
                                extra_link_args = eo_libs + eina_libs)
        modules.append(eo_ext)


    # === Utilities ===
    utils_ext = [
        Extension("utils.deprecated", ["efl/utils/deprecated"+module_suffix],
                            include_dirs = ['include/'],
                            extra_compile_args = eina_cflags,
                            extra_link_args = eina_libs),
        Extension("utils.conversions", ["efl/utils/conversions"+module_suffix],
                            include_dirs = ['include/'],
                            extra_compile_args = eo_cflags,
                            extra_link_args = eo_libs + eina_libs),
        Extension("utils.logger", ["efl/utils/logger"+module_suffix],
                            include_dirs = ['include/'],
                            extra_compile_args = eina_cflags,
                            extra_link_args = eina_libs),
        ]
    modules += utils_ext
    packages.append("efl.utils")


    # === Evas ===
    evas_pkg_config = pkg_config('Evas', 'evas', EFL_MIN_VERSION)

    if evas_pkg_config is not None:

        evas_cflags, evas_libs = evas_pkg_config

        evas_ext = Extension("evas", ["efl/evas/efl.evas"+module_suffix],
                                include_dirs = ['include/'],
                                extra_compile_args = evas_cflags,
                                extra_link_args = evas_libs + eina_libs)
        modules.append(evas_ext)

        # compatibility
        packages.append("evas")
        package_dirs["evas"] = "compat/evas"


    # === Ecore ===
    ecore_pkg_config = pkg_config('Ecore', 'ecore', EFL_MIN_VERSION)
    ecore_file_pkg_config = pkg_config('EcoreFile', 'ecore-file', "1.8.0")

    if ecore_pkg_config is not None and ecore_file_pkg_config is not None and evas_pkg_config is not None:

        ecore_cflags, ecore_libs = ecore_pkg_config
        ecore_file_cflags, ecore_file_libs = ecore_file_pkg_config

        ecore_ext = Extension("ecore", ["efl/ecore/efl.ecore"+module_suffix],
                                include_dirs = ['include/'],
                                extra_compile_args = ecore_cflags + ecore_file_cflags,
                                extra_link_args = ecore_libs + ecore_file_libs + eina_libs + evas_libs)
        modules.append(ecore_ext)

        # compatibility
        packages.append("ecore")
        package_dirs["ecore"] = "compat/ecore"


    # === Edje ===
    edje_pkg_config = pkg_config('Edje', 'edje', EFL_MIN_VERSION)

    if edje_pkg_config is not None and evas_pkg_config is not None:

        edje_cflags, edje_libs = edje_pkg_config

        edje_ext = Extension("edje", ["efl/edje/efl.edje"+module_suffix],
                                include_dirs = ['include/'],
                                extra_compile_args = edje_cflags,
                                extra_link_args = edje_libs + eina_libs + evas_libs)
        modules.append(edje_ext)

        # compatibility
        packages.append("edje")
        package_dirs["edje"] = "compat/edje"

        # --- Edje_Edit ---
        edje_edit_ext = Extension("edje_edit", ["efl/edje/efl.edje_edit"+module_suffix],
                                define_macros = [('EDJE_EDIT_IS_UNSTABLE_AND_I_KNOW_ABOUT_IT', None)],
                                include_dirs = ['include/'],
                                extra_compile_args = edje_cflags,
                                extra_link_args = edje_libs + eina_libs + evas_libs)
        modules.append(edje_edit_ext)


    # Emotion
    emotion_pkg_config = pkg_config('Emotion', 'emotion', EFL_MIN_VERSION)

    if emotion_pkg_config is not None and evas_pkg_config is not None:

        emotion_cflags, emotion_libs = emotion_pkg_config

        emotion_ext = Extension("emotion", ["efl/emotion/efl.emotion"+module_suffix],
                                include_dirs = ['include/'],
                                extra_compile_args = emotion_cflags,
                                extra_link_args = emotion_libs + eina_libs + evas_libs)
        modules.append(emotion_ext)

        # compatibility
        packages.append("emotion")
        package_dirs["emotion"] = "compat/emotion"


    # === dbus mainloop integration ===
    dbus_pkg_config = pkg_config('DBus', 'dbus-python', "0.83.0")

    if dbus_pkg_config is not None and ecore_pkg_config is not None:
        dbus_cflags, dbus_libs = dbus_pkg_config

        dbus_ml_ext = Extension("dbus_mainloop",
                                ["efl/dbus_mainloop/dbus_mainloop"+module_suffix,
                                 "efl/dbus_mainloop/e_dbus.c"],
                                extra_compile_args = dbus_cflags + ecore_cflags,
                                extra_link_args = dbus_libs + ecore_libs)
        modules.append(dbus_ml_ext)

        # compatibility
        packages.append("e_dbus")
        package_dirs["e_dbus"] = "compat/e_dbus"


    # === Elementary ===
    elm_mods = (
        #"access",
        "actionslider",
        "background",
        "box",
        "bubble",
        "button",
        "calendar_elm",
        "check",
        "clock",
        "colorselector",
        "configuration",
        "conformant",
        "ctxpopup",
        "datetime_elm",
        "dayselector",
        "diskselector",
        "entry",
        "fileselector_button",
        "fileselector_entry",
        "fileselector",
        "flip",
        "flipselector",
        "frame",
        "general",
        "gengrid",
        "genlist",
        "gesture_layer",
        #"glview",
        "grid",
        "hover",
        "hoversel",
        "icon",
        "image",
        "index",
        "innerwindow",
        "label",
        "layout_class",
        "layout",
        "list",
        "mapbuf",
        "map",
        "menu",
        "multibuttonentry",
        "naviframe",
        "need",
        "notify",
        "object_item",
        "object",
        "panel",
        "panes",
        "photocam",
        "photo",
        "plug",
        "popup",
        "progressbar",
        "radio",
        "scroller",
        "segment_control",
        "separator",
        "slider",
        "slideshow",
        "spinner",
        #"store",
        "table",
        "theme",
        "thumb",
        "toolbar",
        "transit",
        "video",
        "web",
        "window",
    )

    elm_pkg_config = pkg_config('Elementary', 'elementary', ELM_MIN_VERSION)

    if elm_pkg_config is not None \
    and evas_pkg_config is not None \
    and ecore_pkg_config is not None \
    and emotion_pkg_config is not None:
        elm_cflags, elm_libs = elm_pkg_config

        for m in elm_mods:
            e = Extension(
                "elementary." + m,
                ["efl/elementary/" + m + module_suffix],
                include_dirs = ["include/"],
                extra_compile_args = elm_cflags,
                extra_link_args = elm_libs + eina_libs + evas_libs
                )
            modules.append(e)

        packages.append("efl.elementary")

        # compatibility
        packages.append("elementary")
        package_dirs["elementary"] = "compat/elementary"


setup(
    name = "python-efl",
    fullname = "Python bindings for Enlightenment Foundation Libraries",
    description = "Python bindings for Enlightenment Foundation Libraries",
    version = RELEASE,
    author = "Gustavo Sverzut Barbieri, Simon Busch, Boris 'billiob' Faure, Davide Andreoli, Fabiano Fidêncio, Bruno Dilly, Tiago Falcão, Joost Albers, Kai Huuhko, Ulisses Furquim",
    author_email = "dave@gurumeditation.it, kai.huuhko@gmail.com",
    maintainer = "Kai Huuhko, Davide Andreoli",
    maintainer_email = "kai.huuhko@gmail.com, dave@gurumeditation.it",
    contact = "Enlightenment developer mailing list",
    contact_email = "enlightenment-devel@lists.sourceforge.net",
    url = "http://www.enlightenment.org",
    license = "GNU Lesser General Public License (LGPL)",
    cmdclass = {
        'build_ext': build_ext,
        'build_doc': BuildDoc,
        'clean_generated_files': CleanGenerated
        },
    command_options = {
        'build_doc': {
            'version': ('setup.py', VERSION),
            'release': ('setup.py', RELEASE)
            }
        },
    package_dir = package_dirs,
    packages = packages,
    ext_package = "efl", # The prefix for ext modules/packages
    ext_modules = cythonize(modules, include_path=["include"]),
)
